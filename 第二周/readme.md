
什么样的对象是垃圾
没有被对象引用的对象，如：方法执行完之后的方法局部变量，随着方法栈回收，局部变量也就成为了垃圾

垃圾判断方法
引用计数（有缺陷）：两个垃圾对象如果存在循环相互引用，则会造成两个垃圾对象都无法回收
可达性分析（主流方式）：通过一些root节点，如果该对象无法从root节点通过引用关系到达，则判定该对象为垃圾对象。通常gc root可以为类静态常量引用的对象、虚拟机栈或本地方法栈引用的对象、方法区中常量引用的对象、活跃线程中引用的对象等，简单来说就是当前正在执行相关的对象和常量引用的对象。

标记-清除算法（Mark and Sweep）
1、根据可达性分析标记垃圾对象，并把垃圾对象清除

缺点：碎片化内存较多（不利于较大对象的空间分配，增加gc次数）

复制算法
通过将gc存活的对象复制到一块空内存上来解决 内存碎片化问题。

使用场景：内存复制相对标记清除多了内存复制操作，消耗性能。所以复制算法主要针对对象存活率低的场景。（大部分对象会被一次gc清除），正因为这个特点，所以堆中的年轻代采用的就是复制算法。

标记 - 整理算法
相对标记清除，他多了整理的步骤，减少碎片化内存。同样能减少碎片内存的复制算法对内存的要求相对苛刻，需要两块相同大小的内存供来回复制（因为可能存在一个对象都无法回收的情况），所以仅适用于对象存活率低的情况。
标记 - 整理算法，适用于存活率高，又不想碎片化内存的情况。堆的老年代通常采用的就是这种算法。

一套健全的回收算法（分代收集算法）
JVM的gc算法吸收了各种gc算法的优势，将堆内存分区，老年代和新生代(新生代为了采用复制算法优化，又分为eden，survivor1，survivor2)。新生代一般针对对象朝生夕灭的特性而采用复制算法，通过老年代做担保。老年代的对象在gc后一般存活率较高，一般采用标记清除或标记整理算法。
同时，一个对象在新生代老年代之间流转还有一套规则：
1、新生代对象年纪大了就要进入老年代了（几岁算老年可以配置：-XX：maxTenuringThreshold）。
2、对象体积太大，直接未老先衰，不像年轻人的样子，直接进入老年代（多大体积直接进入老年代可配置：-XX:PretenuerSizeThreshold）。
3、年纪不大，但新生代大小有限，放不下了，之后通过内存担保，进入老年代了。
根据业务对象的场景，还可以配置新生代老年代的内存大小比例，新生代的eden和survivor区的大小比例。

新生代垃圾收集器
单线程收集器：Serial收集器，第一代新生代收集器，单线程收集。
多线程收集器：
ParNew收集器，相比Serial来说，只多了多线程的特性，在多cpu的场景下，效率较高。
Parallel scavenge收集器，相对ParNew，比起关注gc停顿时间，更关注JVM的吞吐量。因此更适合那些不直接面向用户的系统（吞吐量 = JVM运行时间/(JVM运行时间+JVM垃圾收集时间)）

老年代垃圾收集器
serial old：单线程，标记整理算法。
parallel old：多线程，标记整理算法，吞吐量优先。
多线程标记整理CMS：多线程，标记清除算法。

G1（Garbage First）：面向新生代+老年代，对java堆进行二次分区，分为多个相对的region，不是每次都对整个对进行full gc，而更关注每次对分区gc的价值，性价比越高的分区优先gc。
